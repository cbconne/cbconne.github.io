[{"content":"\n黑幕覆盖部分均为涉及剧透内容，请谨慎阅读\n评分：8.5 评价：\n作为一个 galgame，评价游戏基本上就是评价剧情。\n个人评分/评价肯定是比前作/本体要略逊一筹：\n首先，因为剧情背景就是石头门本体的助手 BE 线，在此基础上本作的很多优点其实只是站在原作的肩膀上对剧情进行了进一步的补充，不考虑 0 本体依然非常完整，但是不考虑本体 0 就是一个没头没尾的故事；\n其次，哪怕把本体的剧情考虑进来，0 的剧情也难以和本体媲美。本体的故事结构比较清晰，事实上的剧情线只有一条（助手线），其他分支结局本质上只是各个章节的 if 线。而 0 的各个分支线之间非常松散（印象里这些分支剧情实际上来源于石头门 IP 下的小说之类的其他作品），剧情之间互相独立甚至矛盾。如果没有本体的真结局设定，可以说本作的六个结局是平等的分支线。 至于其他的一些剧情上的疑惑点就不展开了，毕竟没有严格去盘剧情线，所以不确定是我理解错误/记忆错误还是确实剧情上不太严谨了。比如 A/B 线会决定由季的真实身份，但是由季在 A/B 线的分歧点之前就出场了，从这个角度看是由果及因了。当然，有世界线这种东西存在想解释肯定是能解释的。\n","date":"2024-08-22T13:19:31+08:00","image":"https://s2.loli.net/2024/08/22/BnWou8OKMaAYVir.jpg","permalink":"https://cbconne.github.io/p/%E6%B8%B8%E6%88%8F%E8%AE%B0%E5%BD%95-%E5%91%BD%E8%BF%90%E7%9F%B3%E4%B9%8B%E9%97%A8-0/","title":"游戏记录 命运石之门: 0"},{"content":"\n黑幕覆盖部分均为涉及剧透内容，请谨慎阅读\n评分：9(偏客观)~9.5(偏主观) 评价： 剧情：\n剧情上分为两部分，首先是剧情的内容和呈现剧情的结构。\n内容方面，作为一个推理爱好者，这一方面我更关注推理部分或者说诡计部分。本作的诡计我基本满意，但是确实有着不够“推理”的部分：设定系作品的关键设定一般需要在故事开篇至少前期进行说明，以实现作者和读者的“公平”。但显然这部游戏在这方面很糟糕，直接与诡计相关的核心设定 交换身体 直到后期才告知玩家，确切地说，知道这个设定的时候离完全通关就只有伪结局和真结局了。不过这部作品不是一个正儿八经侧重“推理”本身的游戏，悬疑感 \u0026gt; 公平性也无可厚非。\n结构方面可以评价的点就更少了，对打越钢太郎 sensei 的作品略有了解知道这部作品依然是他的固有套路：不同的人物/故事分支线（大多主线/真相无关）各掺杂一些剧情线索，都打完之后有一个伪结局来一个神反转把真相初步解释清楚，之后就一个真结局进一步补充细节或者背景，然后迎来 HE。不过事实证明，在故事能够有及格线以上的质量时，这一套结构确实稳定好用。\n人物：\n本作人物我并不喜欢——也说不上讨厌，更严格地说只是无感而已。可能是因为游戏剧情不过四五天，绝大多数人物是没有弧光可言的。有明显成长的角色比如应太和瑞希在主线剧情中又不是很重要 重要人物其实也有：伊达，警察到杀手再到老父亲这可太有成长了 。\n玩法：\n作为一个游戏，玩法也是不能绕开的。调查环节的聊天和场景交互玩法，无数有调查环节的游戏都是这样的。比较有新意的应该是 psync 环节，通过和梦境中不同的物体进行不同的互动来推进发展进行解谜，不同的选择也会影响剧情线分支。时间限制的设定算是剧情和玩法融合得比较巧妙的一个点，也是解谜的主要难度点。不过很遗憾的是这个玩法只能说初见有趣，真玩了几次之后会发现比起逻辑推理更多的还是看脑洞有没有和制作者合上。而且难度设计也不是很合理，前期甚至中期都太简单，基本上随便选都能初见过，也没有什么时间策略可言；后期难度上来得比较突然，突然就要开始考虑选用合适的时间减少策略来保证在时限内完成，但是其实到这后面也没有多少场 psync 可以玩了。\n","date":"2024-08-15T12:40:30+08:00","image":"https://s2.loli.net/2024/08/16/P6RIB1KmAyr7ifQ.jpg","permalink":"https://cbconne.github.io/p/%E6%B8%B8%E6%88%8F%E8%AE%B0%E5%BD%95-ai-%E6%A2%A6%E5%A2%83%E6%A1%A3%E6%A1%88/","title":"游戏记录 AI: 梦境档案"},{"content":"总述 经过了一段时间的探索和比较，最终使用了 Hugo + Github Actions + Github Pages 的方式来尝试搭建个人页面，同时选择了两个仓库（一个私有仓库用来存放源文件，一个公开仓库用来存放编译后的静态文件）的方式来完成这个过程。\n最终达到效果：\n有一个私有仓库存放 Hugo 项目及内容，多台电脑可以通过 git 实现该仓库的同步，满足（可能存在的）多台电脑编辑内容的需求。 有一个公开仓库存放 Hugo 项目编译后的静态文件，可以通过 Github Pages 访问，这个即为最终的个人页面。 私有仓库的每一次提交（push），触发 Github Actions 进行自动编译并推送到公开仓库，实现自动编译和自动部署。 总体上还是比较满意这个效果的，基本上也能满足个人站点的需求。\n搭建过程 创建仓库 创建两个仓库，一个私有仓库用来存放 Hugo 项目及内容，一个公开仓库用来存放编译后的静态文件。\n前者仓库名称随意，后者名称固定为 \u0026lt;用户名\u0026gt;.github.io。\n创建 Hugo 项目 此处省略安装 Hugo 的步骤，安装参考官方文档或网络上的教程。\n1 2 3 4 5 6 hugo new site \u0026lt;项目名\u0026gt; cd \u0026lt;项目名\u0026gt; git init git submodule add https://github.com/themes-hugo/hugo-theme-learn.git themes/learn echo \u0026#39;theme = \u0026#34;learn\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml hugo server 访问 http://localhost:1313，即可看到 Hugo 项目的默认页面。\n逐句解释：\nhugo new site \u0026lt;项目名\u0026gt;：创建一个名为 \u0026lt;项目名\u0026gt; 的 Hugo 项目。 cd \u0026lt;项目名\u0026gt;：进入项目目录。 git init：初始化 Git 仓库。 git submodule add https://github.com/themes-hugo/hugo-theme-learn.git themes/learn：添加主题。 echo 'theme = \u0026quot;learn\u0026quot;' \u0026gt;\u0026gt; config.toml：配置主题。 hugo server：启动 Hugo 服务器，并自动编译项目。 其中 hugo 相关的命令可以参考 Hugo 官方文档。Hugo 主题可以参考 Hugo 官方主题列表 选取自己喜欢的主题进行安装或者直接在 GitHub 上以\u0026rsquo;hugo+theme\u0026rsquo;为主题搜索。主题的 GitHub 地址内一般都会有主题的安装、使用说明。\n个人建议使用一些 star 较多、更新时间较新、说明比较详细的主题。\n一方面因为 Hugo 更新的原因，一些比较旧的主题内的说明可能不再适用，如：实际上 Hugo 的配置文件已经变化，现在默认的配置文件名称为hugo.yaml，而许多较旧的主题的说明中配置文件名称仍然为config.toml。\n另一方面 Hugo 的自定义配置内容除一些通用的配置（在 Hugo 官方文档内）外，基本都是依赖于主题的自定义配置，主题的文档详细程度决定了在后续调整过程中的难度。\n创建 Github Actions 这里省略将上述 Hugo 项目通过 git 上传到私有仓库的步骤。\nWARN：\n由于时间比较久，部分配置过程的环节可能有所遗漏，后续如果我想起来或者我按自己这篇文档都走不通 （那还写个屁啊！） 的时候会再补充。\n在私有仓库的 .github/workflows 目录下创建一个名为 deploy.yml 的文件，内容可参考如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 name: deploy on: push: workflow_dispatch: jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4.1.7 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3.0.0 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: ls\u0026amp;\u0026amp;hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v4.0.0 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} external_repository: `username`/`username`.github.io publish_branch: main commit_message: ${{ github.event.head_commit.message }} PERSONAL_TOKEN 为 Github 个人令牌，可以在 Github 个人设置中创建，该 TOKEN 需要有 repo 和 workflow 权限。username 为 Github 用户名。\n完成以上步骤后，提交一次推送到私有仓库或手动触发一次 Github Actions ，即可自动触发编译并推送到公开仓库。然后访问 https://username.github.io 即可访问编译后的静态文件。\n其他内容如当前页面使用的主题的部分自定义项、更换页面字体等后续闲(mō)下(yú)来(dē)的(shí)话(hòu)再补充。\n","date":"2024-08-14T13:55:06+08:00","permalink":"https://cbconne.github.io/p/hugo-github-actions-github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%A1%B5%E9%9D%A2/","title":"Hugo+Github Actions+Github Pages 搭建个人页面"},{"content":"背景 分布式锁的应用场景应该还是蛮多的，这里就不赘述了。\n之前在开发中实现分布式锁都是自己基于 Redis 造轮子，虽然也不复杂并且自己实现一次能对分布式锁有更深的了解，但是终归有些麻烦。尤其是新项目需要的时候还得 CV 一次。\n在查询/学习过程中（毫不意外地）发现 Spring 有现成的组件实现，所以决定拿过来使用一次，顺便了解一下。\n使用 引入依赖 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-integration\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.integration\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-integration-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 创建相关的 Bean 1 2 3 4 5 6 7 8 @Configuration public class RedisLockConfig { @Bean public RedisLockRegistry redisLockRegistry(RedisConnectionFactory redisConnectionFactory) { return new RedisLockRegistry(redisConnectionFactory, \u0026#34;lock\u0026#34;); } } 相关代码示例 这里省略注入部分代码，仅展示使用部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 获取锁对象 Lock lock = redisLockRegistry.obtain(\u0026#34;lock\u0026#34;); // 尝试上/获取锁 boolean isLocked = false; try { // 1s 内持续尝试获取锁 isLocked = lock.tryLock(1, TimeUnit.SECONDS); } catch (InterruptedException e) { // 获取锁异常 log.error(\u0026#34;get lock fail\u0026#34;, e); // …… } if (isLocked) { // 获取锁成功 try { // 业务逻辑 log.info(\u0026#34;get lock success\u0026#34;); } catch (Exception e) { // 业务逻辑异常 log.error(\u0026#34;do sth fail\u0026#34;, e); } finally { // 确保解锁 lock.unlock(); } } else { // 获取锁失败 log.info(\u0026#34;get lock fail\u0026#34;); // …… } 踩坑 问题描述 为了尽可能简单测试加锁效果，我的做法是创建一个获取锁不释放的接口，然后重复调用。这样第一次获取锁成功后，后面的调用应该在过期时间内是无法获取的。\n上面都没什么问题，然后我尝试手动删掉 redis 里的锁记录之后发现还是锁着的。甚至超时时间过去之后依然是锁着的。\n排查 当然很容易想到除了 redis，应该还会有其他地方保存着锁信息，这个通过打断点很容易发现： 很明显，在下面获取 redis 锁之前先尝试获取了 localLock 的锁，虽然 redis 的锁已经没了，但 localLock 仍然还在，所以依然被锁。\n只有在 localLock 没被锁，能够获取锁的情况下才回去尝试获取 redis 的锁。然后如果获取 redis 锁失败（返回 false）的情况下又把 localLock 解锁。感觉这部分逻辑有点怪，不排除是个 BUG？之后再研究下吧。\n解决 解决起来也很方便，随便 Google 一下就能找到一篇文档： Distributed lock with Redis and Spring Boot\nIn some situations, you might need to acquire a lock but not release it. For example, you have a @Scheduled task that runs each 15 seconds on each instance and you don’t want it to be run more often than once per 15 seconds.\nTo do it you can get a lock and exit from a method without releasing. In such cases, I suggest calling lockRegistry.expireUnusedOlderThan(TTL) each time before obtaining a lock (actually it is better to call it for all cases). This method removes old not released locks from the map locks and prevents the situation when one instance has a map with old locks and all threads of this instance (except the one which acquired this lock) cannot acquire it.\n按以上的介绍，建议每次获取锁前都调用一次lockRegistry.expireUnusedOlderThan(TTL)来避免问题，按这种方法来进行操作确实解决了该问题。 （不得不吐槽一句，使用中文检索到的相关博文没有看到有提到这一点的……）\n","date":"2023-09-26T11:21:00Z","permalink":"https://cbconne.github.io/p/%E4%BD%BF%E7%94%A8-spring-integration-%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E-redis-%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BB%A5%E5%8F%8A%E8%B8%A9%E5%9D%91/","title":"使用 Spring Integration 实现基于 Redis 的分布式锁以及踩坑"}]