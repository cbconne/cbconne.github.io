[{"content":"\n评分：8.5 评价： 非常优质的横版过关游戏，中规中矩的同时有着一定自己的特色。唯一的明显缺点应该是流程太短吧。 ","date":"2024-09-18T12:27:04+08:00","image":"https://s2.loli.net/2024/09/18/klZ9V7iQcPSvFKD.jpg","permalink":"https://cbconne.github.io/p/%E6%B8%B8%E6%88%8F%E8%AE%B0%E5%BD%95-%E7%A2%B3%E9%85%B8%E5%8D%B1%E6%9C%BA/","title":"游戏记录 碳酸危机"},{"content":"背景说明 终于还是购买了 Steam Deck，在金钱的督促下最近电子阳痿缓解了很多，每天也多多少少会玩一会儿游戏。然后在折腾 Steam Deck 的过程中发现有个插件能够记录 Steam Deck 上的游戏时长，因此启发了我：既然我大多数时候游戏都是 Steam 在线游玩的，那是否能够通过 Steam 本身的一些 API 来实现记录每天的游戏时长呢？然后将每天的信息存下来，就能通过简单的减法来计算出每日各个游戏的时长了。\n具体实现 Steam API 寻找 Steam 的 API 其实比较难找，因为官方的、成体系的、面向普通开发者 API 文档找起来很困难也不够新，看起来最正式、有良好维护的其实是面向一些游戏相关开发工作的 Steamworks API 文档：Steamworks API 概览。\n面向普通开发者的 API 文档：Steam Web API 文档、Steam Web API，看上去就是一副缺少维护的样子，接口也都还是 http 的，虽然确实能调通。\n最后还是找到了一个第三方提供的 API 文档：Steam Web API Documentation（GitHub 地址：SteamWebAPIDocumentation），看说明来源是通过 Steam 官方提供的 API 来获取所有支持的 API。\nThis is a static page that is automatically generated from GetSupportedAPIList using public and publisher keys. Additionally service methods are parsed from Steam client\u0026rsquo;s protobuf files.\n但是实际测下来，即使是 Steam 官方接口返回的接口调用信息也是不准确的，如：GetOwnedGames 接口显示可以通过 appids_filter 来筛选需要查询的游戏，但是实际不生效，然后看到 Steam Web API 里又写到：\nappids_filter\nYou can optionally filter the list to a set of appids. Note that these cannot be passed as a URL parameter, instead you must use the JSON format described in Steam_Web_API#Calling_Service_interfaces. The expected input is an array of integers (in JSON: \u0026ldquo;appids_filter: [ 440, 500, 550 ]\u0026rdquo; )\n和\nCalling Service interfaces\nThere is a new style of WebAPI which we refer to as \u0026ldquo;Services\u0026rdquo;. They function in many ways like the WebAPIs you are used to, the main difference being that all service APIs will accept their arguments as a single JSON blob in addition to taking them as GET or POST parameters. To pass in data as JSON, invoke the webapi with a parameter set like:\n?key=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\u0026amp;format=json\u0026amp;input_json={steamid: 76561197972495328}\nNote that the JSON will need to be URL-encoded. The \u0026ldquo;key\u0026rdquo; and \u0026ldquo;format\u0026rdquo; fields should still be passed as separate parameters, as before. POST requests are supported as well.\nYou can identify if a WebAPI is a \u0026ldquo;Service\u0026rdquo; by the name of the interface; if it ends in \u0026ldquo;Service\u0026rdquo; like \u0026ldquo;IPlayerService\u0026rdquo;, then it supports this additional method of passing parameter data. Some Service methods have parameters that are more complex structures and require this different input format.\n但是实际上都是在扯淡……按照文档说明的规则去写同样调不通。\n查下来有个已经归档的项目里的说法是，参考 TF2 wiki 内的说法，需要使用以下格式：\nappids_filter (Optional) (uint32)\nRestricts results to the appids passed here. This is an array and should be passed like appids_filter[0]=440\u0026amp;appids_filter[1]=570\n经过验证以上方式调用是有效的。\n同时，文档里说可以使用 language 参数来修改返回的 appinfo 的语言，这个实测下来也无效——或者这个参数非常偏门，不是 zh-CN、Chinese 之类正常逻辑能想到的。好在也不太有这个需求\u0026amp;有中文信息的游戏也不多。\n游戏时长获取方案 一开始打算使用 GetRecentlyPlayedGames 直接获取两周内各游戏的游戏时长然后通过每日定时执行脚本计算来获取每日的具体时长信息。但实际尝试下来发现“两周内时长”是一个滑窗动值，要根据这个计算出每日的时长信息是不足的，比如：游戏 A 昨天的两周内游戏时长是 14 小时，今天的两周内游戏时长是 15 小时，这只能够计算出游戏 A 今天的游戏时长比两周前的那天多 1 小时，并不能获取具体当天游戏时长。也许通过某些数学方式能够获取，但是总归太过麻烦。\n选择使用其他接口，最终决定使用 GetOwnedGames 接口来获取，该接口会返回所有拥有的游戏，并返回该游戏的历史总游戏时长，使用该接口每天记录一次数据，并与前一天的数据做差值计算，即可获取到当天的各游戏时长。\n验证过程中发现该方案的问题：GetOwnedGames 如同字面意思，只能返回“Owned”的游戏，而 Steam 最近的新家庭共享功能可以让我玩到我没有购买但是家庭组内其他成员购买的游戏。在这种情况下，通过 GetOwnedGames 获取到的信息中是缺少这些游戏的。\n最后思考下来的解决方案是仍然需要使用 GetRecentlyPlayedGames 来进行补充，该接口能够正常显示两周内玩过的家庭共享游戏信息，包括总游戏时长。因此，在使用 GetOwnedGames 获取数据后，再通过 GetRecentlyPlayedGames 获取数据并对其中缺失的游戏进行补充，即可有效获取到所有游戏时长信息。\n随后的事情就比较简单了，用今天的数据和前一天的数据做差值计算，即可得到当天的各游戏时长；如果存在昨天不存在的游戏数据说明是今天第一次玩的，直接用现有的游戏总时长即可。\n定时脚本执行及数据保存方案 一开始其实考虑过在自己买的云服务器上定时运行脚本并，但是想了想后面云服务器到期大概率不太会继续续用了，即使续用大概率也会购买另一家云厂商的，到时候再进行数据迁移会比较麻烦。\n最后考虑了多种方案还是决定白嫖 GitHub 的资源，使用 GitHub Actions 来实现定时的脚本执行，并使用 GitHub 仓库本身来保存数据。\n大致方案如下：\n新建私有仓库，将上述游戏时长获取脚本保存到该仓库中； 新建一个 GitHub Action，配置定时执行，自动拉取该仓库并执行脚本，最后将数据通过 commit 和 push 保存到该仓库中。 图表绘制 这个暂时先不做，目前先实现纯文本记录。\n代码 游戏时长获取 以下为游戏时长获取脚本，使用 Python 实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 import requests import pandas as pd import os import datetime import pytz def get_steam_data(): \u0026#34;\u0026#34;\u0026#34; 调用 GetOwnedGames 和 GetRecentlyPlayedGames 接口获取游戏时长数据 将结果保存为 CSV 文件 \u0026#34;\u0026#34;\u0026#34; all_url = \u0026#34;https://api.steampowered.com/IPlayerService/GetOwnedGames/v1\u0026#34; recently_url = ( \u0026#34;https://api.steampowered.com/IPlayerService/GetRecentlyPlayedGames/v1\u0026#34; ) # 将 key 和 steamid 配置在代码仓库的 Actions secrets and variables 中，Actions 执行时将其赋值给环境变量 key = os.environ.get(\u0026#34;STEAM_KEY\u0026#34;) steamid = os.environ.get(\u0026#34;STEAM_ID\u0026#34;) # 检查 key 和 steamid 是否设置 if key is None or steamid is None: raise ValueError(\u0026#34;STEAM_KEY or STEAM_ID is not set\u0026#34;) params = { \u0026#34;key\u0026#34;: key, \u0026#34;steamid\u0026#34;: steamid, # 是否包含游戏信息，该参数为 True 时会返回游戏名称 \u0026#34;include_appinfo\u0026#34;: True, # 是否包含免费游戏信息，有两个参数，不确定这两个之间的区别 \u0026#34;include_played_free_games\u0026#34;: True, \u0026#34;include_free_sub\u0026#34;: True, } # 获取所有游戏信息 all_response = requests.request(\u0026#34;GET\u0026#34;, all_url, params=params) all_res = all_response.json().get(\u0026#34;response\u0026#34;).get(\u0026#34;games\u0026#34;) all_steam_df = pd.DataFrame(all_res) # 获取当前时间，由于 GitHub Actions 使用的是UTC 时间，因此需要转换为北京时间，后续所有时间相关内容均同 now_time = datetime.datetime.now(pytz.timezone(\u0026#34;Asia/Shanghai\u0026#34;)) all_steam_df[\u0026#34;creation_time\u0026#34;] = now_time # 个人强迫症，避免数据转换过程中出现浮点数导致出现无意义的.0 all_steam_df[\u0026#34;rtime_last_played\u0026#34;] = all_steam_df[\u0026#34;rtime_last_played\u0026#34;].astype(int) all_steam_df[\u0026#34;playtime_disconnected\u0026#34;] = all_steam_df[ \u0026#34;playtime_disconnected\u0026#34; ].astype(int) # 此处由于该接口返回数据两周内游戏市场为 0 时会为空，因此需要将空值填充为 0，也避免转换失败 all_steam_df[\u0026#34;playtime_2weeks\u0026#34;] = ( all_steam_df[\u0026#34;playtime_2weeks\u0026#34;].fillna(0).astype(int) ) # 创建文件夹，其实只需要初次创建后即可删除 os.makedirs(\u0026#34;./data/steam_data\u0026#34;, exist_ok=True) # 保存数据，文件名记录日期 all_steam_df.to_csv( f\u0026#34;./data/steam_data/steam_data_{now_time.strftime(\u0026#39;%Y%m%d\u0026#39;)}.csv\u0026#34;, index=False ) # 获取两周内游戏信息 recently_response = requests.request(\u0026#34;GET\u0026#34;, recently_url, params=params) recently_res = recently_response.json().get(\u0026#34;response\u0026#34;).get(\u0026#34;games\u0026#34;) steam_df = pd.DataFrame(recently_res) steam_df[\u0026#34;created_time\u0026#34;] = now_time os.makedirs(\u0026#34;./data/playtime_2week_data\u0026#34;, exist_ok=True) steam_df.to_csv( f\u0026#34;./data/playtime_2week_data/steam_playtime_2week_{now_time.strftime(\u0026#39;%Y%m%d\u0026#39;)}.csv\u0026#34;, index=False, ) def merge_steam_data(): \u0026#34;\u0026#34;\u0026#34; 合并所有游戏数据与两周内游戏数据，由于 Steam 的家庭共享功能， 获取所有游戏数据时无法获取家庭共享游戏数据，因此需要合并数据 \u0026#34;\u0026#34;\u0026#34; # 获取当天的日期，以获取准确的文件名 today_date = datetime.datetime.now(pytz.timezone(\u0026#34;Asia/Shanghai\u0026#34;)).strftime( \u0026#34;%Y%m%d\u0026#34; ) # 从 CSV 文件中读取数据 all_game_info = pd.read_csv(f\u0026#34;./data/steam_data/steam_data_{today_date}.csv\u0026#34;) recently_game_info = pd.read_csv( f\u0026#34;./data/playtime_2week_data/steam_playtime_2week_{today_date}.csv\u0026#34; ) # 获取不在 all_game_info 中的数据 not_in_all_game_info = recently_game_info[ ~recently_game_info[\u0026#34;appid\u0026#34;].isin(all_game_info[\u0026#34;appid\u0026#34;]) ] # 使用两周内游戏数据补充数据 now_time = datetime.datetime.now(pytz.timezone(\u0026#34;Asia/Shanghai\u0026#34;)) for index, row in not_in_all_game_info.iterrows(): new_row = { \u0026#34;appid\u0026#34;: row[\u0026#34;appid\u0026#34;], \u0026#34;name\u0026#34;: row[\u0026#34;name\u0026#34;], \u0026#34;playtime_forever\u0026#34;: row[\u0026#34;playtime_forever\u0026#34;], \u0026#34;playtime_windows_forever\u0026#34;: row[\u0026#34;playtime_windows_forever\u0026#34;], \u0026#34;playtime_mac_forever\u0026#34;: row[\u0026#34;playtime_mac_forever\u0026#34;], \u0026#34;playtime_linux_forever\u0026#34;: row[\u0026#34;playtime_linux_forever\u0026#34;], \u0026#34;playtime_deck_forever\u0026#34;: row[\u0026#34;playtime_deck_forever\u0026#34;], \u0026#34;playtime_2weeks\u0026#34;: row[\u0026#34;playtime_2weeks\u0026#34;], \u0026#34;creation_time\u0026#34;: now_time, } all_game_info = pd.concat( [all_game_info, pd.DataFrame([new_row])], ignore_index=True ) # 此处合并数据后部分字段出现浮点数，因此转换为整数 all_game_info[\u0026#34;rtime_last_played\u0026#34;] = ( all_game_info[\u0026#34;rtime_last_played\u0026#34;].fillna(0).astype(int) ) all_game_info[\u0026#34;playtime_disconnected\u0026#34;] = ( all_game_info[\u0026#34;playtime_disconnected\u0026#34;].fillna(0).astype(int) ) # 保存数据 all_game_info.to_csv(f\u0026#34;./data/steam_data/steam_data_{today_date}.csv\u0026#34;, index=False) def get_playing_time(): \u0026#34;\u0026#34;\u0026#34; 获取最近一天的游戏时长信息 \u0026#34;\u0026#34;\u0026#34; # 获取当天的日期，以获取准确的文件名 today_date = datetime.datetime.now(pytz.timezone(\u0026#34;Asia/Shanghai\u0026#34;)).strftime( \u0026#34;%Y%m%d\u0026#34; ) # 获取昨天的日期 yesterday_date = ( datetime.datetime.now(pytz.timezone(\u0026#34;Asia/Shanghai\u0026#34;)) - datetime.timedelta(1) ).strftime(\u0026#34;%Y%m%d\u0026#34;) # 从 CSV 文件中读取数据 today_game_info = pd.read_csv(f\u0026#34;./data/steam_data/steam_data_{today_date}.csv\u0026#34;) yesterday_game_info = pd.read_csv( f\u0026#34;./data/steam_data/steam_data_{yesterday_date}.csv\u0026#34; ) # 计算最近一天的游戏时长 # 针对每个 appid，计算当天游戏时长与昨天游戏时长的差值 # 进行 merge 操作，使用 left join，因为今天可能存在昨天没有的游戏信息（刚购买） merge_game_info = pd.merge( today_game_info, yesterday_game_info, on=\u0026#34;appid\u0026#34;, how=\u0026#34;left\u0026#34;, suffixes=(\u0026#34;_new\u0026#34;, \u0026#34;_old\u0026#34;), ) # 计算游戏时长 merge_game_info[\u0026#34;playing_time\u0026#34;] = merge_game_info.apply( lambda x: x[\u0026#34;playtime_forever_new\u0026#34;] if pd.isna(x[\u0026#34;playtime_forever_old\u0026#34;]) else int(x[\u0026#34;playtime_forever_new\u0026#34;] - x[\u0026#34;playtime_forever_old\u0026#34;]), axis=1, ) # 仅保留一列游戏名称，删除多余的列 merge_game_info.drop(\u0026#34;name_old\u0026#34;, axis=1, inplace=True) merge_game_info.rename(columns={\u0026#34;name_new\u0026#34;: \u0026#34;name\u0026#34;}, inplace=True) # 仅保留非零游戏时长的数据 merge_game_info = merge_game_info[merge_game_info[\u0026#34;playing_time\u0026#34;] \u0026gt; 0] merge_game_info = merge_game_info[[\u0026#34;appid\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;playing_time\u0026#34;]] time = datetime.datetime.now(pytz.timezone(\u0026#34;Asia/Shanghai\u0026#34;)) # 调整字段顺序 merge_game_info = merge_game_info[[\u0026#34;appid\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;playing_time\u0026#34;]] # 记录数据日期，由于定时任务在凌晨执行，因此计算出来的游戏时长数据是昨天的 merge_game_info[\u0026#34;playtime_date\u0026#34;] = ( datetime.datetime.now(pytz.timezone(\u0026#34;Asia/Shanghai\u0026#34;)) - datetime.timedelta(1) ).date() merge_game_info[\u0026#34;creation_time\u0026#34;] = time # 保存数据 os.makedirs(\u0026#34;./data/playing_time_data\u0026#34;, exist_ok=True) merge_game_info.to_csv( f\u0026#34;./data/playing_time_data/playing_time_{today_date}.csv\u0026#34;, index=False ) # 主函数 if __name__ == \u0026#34;__main__\u0026#34;: get_steam_data() merge_steam_data() get_playing_time() GitHub Actions yaml 配置 以下为 GitHub Actions 的 yaml 配置文件。\n基本都是 GitHub Actions 的八股文，可以参考官方文档或者网络上其他文档。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 name: get_steam_playtime_data on: # 定时执行，由于 GitHub Actions 使用 UTC 时间，因此此处设置为 18:00，表示在北京时间 02:00 执行 schedule: - cron: \u0026#34;0 18 * * *\u0026#34; # 允许手动触发，便于调试 workflow_dispatch: jobs: get_steam_playtime_data: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Set up Python uses: actions/setup-python@v5 with: python-version: \u0026#34;3.12\u0026#34; cache: \u0026#34;pip\u0026#34; cache-dependency-path: ./script/requirements.txt - name: Install dependencies run: pip install -r ./script/requirements.txt - name: Run script env: STEAM_KEY: ${{ secrets.STEAM_KEY }} STEAM_ID: ${{ vars.STEAM_ID }} run: python ./script/get_playtime.py - name: Commit changes # 此处使用命令在 commit message 中添加时间信息 run: | git config --local user.email \u0026#34;action@github.com\u0026#34; git config --local user.name \u0026#34;GitHub Action\u0026#34; git add . git commit -m \u0026#34;Update Steam Playtime Data `TZ=\u0026#39;Asia/Shanghai\u0026#39; date +\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;`\u0026#34; - name: Push changes uses: ad-m/github-push-action@master with: branch: ${{ github.ref }} 最终效果 ","date":"2024-09-18T12:18:47+08:00","permalink":"https://cbconne.github.io/p/%E4%BD%BF%E7%94%A8-github-actions-%E5%AE%9E%E7%8E%B0-steam-%E6%AF%8F%E5%A4%A9%E6%B8%B8%E6%88%8F%E6%97%B6%E9%95%BF%E8%AE%B0%E5%BD%95/","title":"使用 Github Actions 实现 Steam 每天游戏时长记录"},{"content":"\n评分：3（十分制） 印象里是当年刚出就买了，然后玩了一会儿之后五年多没完了，借着 Steam Deck 带来的游戏热情下载回来重新开始玩。\n总体评价就是，没买别买、买了别玩儿。\n评价： 剧情：\n作为一个 RPG 游戏，剧情应该是比较重要的一部分。但是除了刚上来刚看到那些无厘头梗可能略有新意，游戏时间超过 3 小时之后就开始无聊了，\n玩法：\n和剧情一样，3 个小时内——或者可以再久一些——玩法还是可以吸引人的。但是到了后面，基本上就是一本“怎么把 RPG 游戏做得又臭又长”的教科书了：剧情嘛，是没有意思的；刷刷刷嘛，是没有价值的；角色成长嘛，是单调重复没什么效果的；敌人嘛，是只会堆数量的；任务嘛，翻来覆去就是那么几类的。\n可以说，在现在这个年代，竟然还会有这么折磨的 RPG 游戏。\n支撑我玩下去的信念有两个：一个是我习惯要玩就玩完，即使中间吃灰了很长一段时间我一般也还是会把它玩完；另一个是说服我自己，总得玩点烂游戏，否则怎么能体验得到我平时玩的好游戏优秀在哪呢？\n","date":"2024-09-04T14:01:25+08:00","image":"https://s2.loli.net/2024/08/27/xKLu8GElzYetCgW.jpg","permalink":"https://cbconne.github.io/p/%E6%B8%B8%E6%88%8F%E8%AE%B0%E5%BD%95-%E5%9F%BA%E5%9B%A0%E7%89%B9%E5%B7%A5/","title":"游戏记录 基因特工"},{"content":"Summel 介绍 Summel 是一个规则很简单的数字游戏，官网即有规则/玩法介绍。简单来说，就是给定 6 个已知数字和 1 个目标数字，要在有限（最多 5 次）的初等数学运算（加减乘除，且计算后不能出现非正整数）中，通过计算得到目标数字。\n基本思路 虽然这是一个数字游戏，可能也有一些比较深的数学知识能够解决或者辅助解决，但是使用计算机来解决这个问题的思路其实还是一个力大砖飞：\n由于给出的已知数字只有 6 个，所以实际上全部的排列组合是非常有限的。因此完全可以暴力穷举所有的组合，然后找出满足条件的组合。\n优化 单纯的穷举虽然肯定可以得到结果，但是实际上仍然会比较慢，因此需要考虑优化。\n首先可以注意到，我们可以将排列组合和计算同时进行，这样当计算到一些不符合要求的运算时（出现非正整数），可以直接跳过（类似于机器学习的剪枝操作）。在这种优化思路下，能够大大减少各种排列情况，因为减法 A-B 和 B-A 两者能够排除一种（A=B 时例外），而除法更是在大部分情况下均会出现非正整数。\n因此，考虑使用递归方式来进行穷举，以实现在穷举过程中的剪枝操作。\n具体实现 代码及注释见下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 # Summel Solver # 给定的数字 numbers = [4, 5, 25, 50, 75, 100] # 目标数字 target = 459 # 可用的运算符 operators = [\u0026#34;+\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;/\u0026#34;] # 最终的结果 results = [] # 递归函数，根据当前的数字/计算式列表进行组合，生成所有可能的表达式 def generate_expressions(nums): \u0026#34;\u0026#34;\u0026#34; 递归函数，生成所有可能的表达式 :param nums: 当前的数字/计算式列表（字符串），可能为数字（\u0026#34;4\u0026#34;)，也可能为表达式（\u0026#34;(4+5)\u0026#34;) :return: None \u0026#34;\u0026#34;\u0026#34; # 根据经验，一般的 summel 问题最少在 4 次运算时就可以得到目标值，此时列表可能为“1 个数字”+“5 个数字组成的计算式” # 所以在列表长度小于等于 2 时进行运算判断是否满足目标值，以覆盖 4 次运算的情况和 5 次运算的情况 if len(nums) \u0026lt;= 2: # 计算当前列表中的计算式是否满足目标值 for num in nums: # todo：此处其实还有优化空间，列表长度小于等于 2 时我们实际仅需要“1 个数字”+“5 个数字组成的计算式”这种情况 # 而 2+4、3+3 的情况下，获取到目标值的概率很小（正常难度下），可以不用进行运算直接跳过 # 当然为了兼容一些比较简单的难度，还是保持现状，目前的执行时间大部分情况下能够接受 try: if eval(num) == target: # 满足目标值，将结果添加到答案列表中 results.append(num) except ZeroDivisionError: # 除法出现除数为 0 的情况，跳过 # 理论上不会出现，因为仅有减法操作后会出现 0 ，而下面在减法操作时已将得出 0 的结果跳过 pass # 列表中有 2 个以上的数字/表达式时，通过循环遍历所有“取出两个数字/表达式”并进行计算的操作 for i in range(len(nums)): for j in range(i + 1, len(nums)): for op in operators: # 除法的特殊处理 if op == \u0026#34;/\u0026#34;: try: # 判断计算结果是否为自然数，若为自然数则将取出的两个数字/计算式组成一个新的计算式 # 修改列表：移除这两个数字/表达式，将新的计算式添加到列表中 # 进行进一步的递归 # todo: 此处可以优化，因为 A!=B 的情况下 A/B 和 B/A 不可能都为正整数，而 A==B 的情况下也不需要交换顺序计算 if eval(f\u0026#34;({nums[i]} {op} {nums[j]})\u0026#34;) % 1 == 0: new_nums = nums[:i] + nums[i + 1 : j] + nums[j + 1 :] new_nums.append(f\u0026#34;({nums[i]} {op} {nums[j]})\u0026#34;) generate_expressions(new_nums) if eval(f\u0026#34;({nums[j]} {op} {nums[i]})\u0026#34;) % 1 == 0: new_nums = nums[:i] + nums[i + 1 : j] + nums[j + 1 :] new_nums.append(f\u0026#34;({nums[j]} {op} {nums[i]})\u0026#34;) generate_expressions(new_nums) except ZeroDivisionError: # 除法出现除数为 0 的情况，跳过 # 同上 continue # 减法特殊处理 elif op == \u0026#34;-\u0026#34;: # 判断计算结果是否大于 0，若大于 0 则将取出的两个数字/表达式组成一个新的计算式 # 修改列表：移除这两个数字/表达式，将新的计算式添加到列表中 # 进行进一步的递归 # todo: 此处可以优化，同样可以仅判断一个分支 if eval(f\u0026#34;({nums[i]} {op} {nums[j]})\u0026#34;) \u0026gt; 0: new_nums = nums[:i] + nums[i + 1 : j] + nums[j + 1 :] new_nums.append(f\u0026#34;({nums[i]} {op} {nums[j]})\u0026#34;) generate_expressions(new_nums) if eval(f\u0026#34;({nums[j]} {op} {nums[i]})\u0026#34;) \u0026gt; 0: new_nums = nums[:i] + nums[i + 1 : j] + nums[j + 1 :] new_nums.append(f\u0026#34;({nums[j]} {op} {nums[i]})\u0026#34;) generate_expressions(new_nums) # 加法和乘法不会得到非正整数且考虑满足交换律，无须特殊处理或交换顺序 else: new_nums = nums[:i] + nums[i + 1 : j] + nums[j + 1 :] new_nums.append(f\u0026#34;({nums[i]} {op} {nums[j]})\u0026#34;) generate_expressions(new_nums) # 初始化，将数字列表转换为字符串列表，作为初始的计算式列表 initial_exprs = list(map(str, numbers)) # 开始递归 generate_expressions(initial_exprs) # 输出结果 if results: for result in results: # 将全部结果输出，便于找到运算次数最少的结果 print(f\u0026#34;Found solution: {result} = {target}\u0026#34;) else: print(\u0026#34;No solution found\u0026#34;) 执行下来基本上一分钟之内能够出结果，并且能够兼容特殊模式（比如目标数字为 10，给出 5 个数字，要求使用到全部数字）\n","date":"2024-08-27T15:46:34+08:00","permalink":"https://cbconne.github.io/p/%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E8%AE%A1%E7%AE%97-summel-%E7%AD%94%E6%A1%88/","title":"递归方式计算 Summel 答案"},{"content":"\n黑幕覆盖部分均为涉及剧透内容，请谨慎阅读\n评分：8.5 评价：\n作为一个 galgame，评价游戏基本上就是评价剧情。\n个人评分/评价肯定是比前作/本体要略逊一筹：\n首先，因为剧情背景就是石头门本体的助手 BE 线，在此基础上本作的很多优点其实只是站在原作的肩膀上对剧情进行了进一步的补充，不考虑 0 本体依然非常完整，但是不考虑本体 0 就是一个没头没尾的故事；\n其次，哪怕把本体的剧情考虑进来，0 的剧情也难以和本体媲美。本体的故事结构比较清晰，事实上的剧情线只有一条（助手线），其他分支结局本质上只是各个章节的 if 线。而 0 的各个分支线之间非常松散（印象里这些分支剧情实际上来源于石头门 IP 下的小说之类的其他作品），剧情之间互相独立甚至矛盾。如果没有本体的真结局设定，可以说本作的六个结局是平等的分支线。 至于其他的一些剧情上的疑惑点就不展开了，毕竟没有严格去盘剧情线，所以不确定是我理解错误/记忆错误还是确实剧情上不太严谨了。比如 A/B 线会决定由季的真实身份，但是由季在 A/B 线的分歧点之前就出场了，从这个角度看是由果及因了。当然，有世界线这种东西存在想解释肯定是能解释的。\n","date":"2024-08-22T13:19:31+08:00","image":"https://s2.loli.net/2024/08/22/BnWou8OKMaAYVir.jpg","permalink":"https://cbconne.github.io/p/%E6%B8%B8%E6%88%8F%E8%AE%B0%E5%BD%95-%E5%91%BD%E8%BF%90%E7%9F%B3%E4%B9%8B%E9%97%A8-0/","title":"游戏记录 命运石之门: 0"},{"content":"\n黑幕覆盖部分均为涉及剧透内容，请谨慎阅读\n评分：9(偏客观)~9.5(偏主观) 评价： 剧情：\n剧情上分为两部分，首先是剧情的内容和呈现剧情的结构。\n内容方面，作为一个推理爱好者，这一方面我更关注推理部分或者说诡计部分。本作的诡计我基本满意，但是确实有着不够“推理”的部分：设定系作品的关键设定一般需要在故事开篇至少前期进行说明，以实现作者和读者的“公平”。但显然这部游戏在这方面很糟糕，直接与诡计相关的核心设定 交换身体 直到后期才告知玩家，确切地说，知道这个设定的时候离完全通关就只有伪结局和真结局了。不过这部作品不是一个正儿八经侧重“推理”本身的游戏，悬疑感 \u0026gt; 公平性也无可厚非。\n结构方面可以评价的点就更少了，对打越钢太郎 sensei 的作品略有了解知道这部作品依然是他的固有套路：不同的人物/故事分支线（大多主线/真相无关）各掺杂一些剧情线索，都打完之后有一个伪结局来一个神反转把真相初步解释清楚，之后就一个真结局进一步补充细节或者背景，然后迎来 HE。不过事实证明，在故事能够有及格线以上的质量时，这一套结构确实稳定好用。\n人物：\n本作人物我并不喜欢——也说不上讨厌，更严格地说只是无感而已。可能是因为游戏剧情不过四五天，绝大多数人物是没有弧光可言的。有明显成长的角色比如应太和瑞希在主线剧情中又不是很重要 重要人物其实也有：伊达，警察到杀手再到老父亲这可太有成长了 。\n玩法：\n作为一个游戏，玩法也是不能绕开的。调查环节的聊天和场景交互玩法，无数有调查环节的游戏都是这样的。比较有新意的应该是 psync 环节，通过和梦境中不同的物体进行不同的互动来推进发展进行解谜，不同的选择也会影响剧情线分支。时间限制的设定算是剧情和玩法融合得比较巧妙的一个点，也是解谜的主要难度点。不过很遗憾的是这个玩法只能说初见有趣，真玩了几次之后会发现比起逻辑推理更多的还是看脑洞有没有和制作者合上。而且难度设计也不是很合理，前期甚至中期都太简单，基本上随便选都能初见过，也没有什么时间策略可言；后期难度上来得比较突然，突然就要开始考虑选用合适的时间减少策略来保证在时限内完成，但是其实到这后面也没有多少场 psync 可以玩了。\n","date":"2024-08-15T12:40:30+08:00","image":"https://s2.loli.net/2024/08/16/P6RIB1KmAyr7ifQ.jpg","permalink":"https://cbconne.github.io/p/%E6%B8%B8%E6%88%8F%E8%AE%B0%E5%BD%95-ai-%E6%A2%A6%E5%A2%83%E6%A1%A3%E6%A1%88/","title":"游戏记录 AI: 梦境档案"},{"content":"总述 经过了一段时间的探索和比较，最终使用了 Hugo + Github Actions + Github Pages 的方式来尝试搭建个人页面，同时选择了两个仓库（一个私有仓库用来存放源文件，一个公开仓库用来存放编译后的静态文件）的方式来完成这个过程。\n最终达到效果：\n有一个私有仓库存放 Hugo 项目及内容，多台电脑可以通过 git 实现该仓库的同步，满足（可能存在的）多台电脑编辑内容的需求。 有一个公开仓库存放 Hugo 项目编译后的静态文件，可以通过 Github Pages 访问，这个即为最终的个人页面。 私有仓库的每一次提交（push），触发 Github Actions 进行自动编译并推送到公开仓库，实现自动编译和自动部署。 总体上还是比较满意这个效果的，基本上也能满足个人站点的需求。\n搭建过程 创建仓库 创建两个仓库，一个私有仓库用来存放 Hugo 项目及内容，一个公开仓库用来存放编译后的静态文件。\n前者仓库名称随意，后者名称固定为 \u0026lt;用户名\u0026gt;.github.io。\n创建 Hugo 项目 此处省略安装 Hugo 的步骤，安装参考官方文档或网络上的教程。\n1 2 3 4 5 6 hugo new site \u0026lt;项目名\u0026gt; cd \u0026lt;项目名\u0026gt; git init git submodule add https://github.com/themes-hugo/hugo-theme-learn.git themes/learn echo \u0026#39;theme = \u0026#34;learn\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml hugo server 访问 http://localhost:1313，即可看到 Hugo 项目的默认页面。\n逐句解释：\nhugo new site \u0026lt;项目名\u0026gt;：创建一个名为 \u0026lt;项目名\u0026gt; 的 Hugo 项目。 cd \u0026lt;项目名\u0026gt;：进入项目目录。 git init：初始化 Git 仓库。 git submodule add https://github.com/themes-hugo/hugo-theme-learn.git themes/learn：添加主题。 echo 'theme = \u0026quot;learn\u0026quot;' \u0026gt;\u0026gt; config.toml：配置主题。 hugo server：启动 Hugo 服务器，并自动编译项目。 其中 hugo 相关的命令可以参考 Hugo 官方文档。Hugo 主题可以参考 Hugo 官方主题列表 选取自己喜欢的主题进行安装或者直接在 GitHub 上以\u0026rsquo;hugo+theme\u0026rsquo;为主题搜索。主题的 GitHub 地址内一般都会有主题的安装、使用说明。\n个人建议使用一些 star 较多、更新时间较新、说明比较详细的主题。\n一方面因为 Hugo 更新的原因，一些比较旧的主题内的说明可能不再适用，如：实际上 Hugo 的配置文件已经变化，现在默认的配置文件名称为hugo.yaml，而许多较旧的主题的说明中配置文件名称仍然为config.toml。\n另一方面 Hugo 的自定义配置内容除一些通用的配置（在 Hugo 官方文档内）外，基本都是依赖于主题的自定义配置，主题的文档详细程度决定了在后续调整过程中的难度。\n创建 Github Actions 这里省略将上述 Hugo 项目通过 git 上传到私有仓库的步骤。\nWARN：\n由于时间比较久，部分配置过程的环节可能有所遗漏，后续如果我想起来或者我按自己这篇文档都走不通 （那还写个屁啊！） 的时候会再补充。\n在私有仓库的 .github/workflows 目录下创建一个名为 deploy.yml 的文件，内容可参考如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 name: deploy on: push: workflow_dispatch: jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4.1.7 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3.0.0 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: ls\u0026amp;\u0026amp;hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v4.0.0 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} external_repository: `username`/`username`.github.io publish_branch: main commit_message: ${{ github.event.head_commit.message }} PERSONAL_TOKEN 为 Github 个人令牌，可以在 Github 个人设置中创建，该 TOKEN 需要有 repo 和 workflow 权限。username 为 Github 用户名。\n完成以上步骤后，提交一次推送到私有仓库或手动触发一次 Github Actions ，即可自动触发编译并推送到公开仓库。然后访问 https://username.github.io 即可访问编译后的静态文件。\n其他内容如当前页面使用的主题的部分自定义项、更换页面字体等后续闲(mō)下(yú)来(dē)的(shí)话(hòu)再补充。\n","date":"2024-08-14T13:55:06+08:00","permalink":"https://cbconne.github.io/p/hugo-github-actions-github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%A1%B5%E9%9D%A2/","title":"Hugo+Github Actions+Github Pages 搭建个人页面"},{"content":"背景 分布式锁的应用场景应该还是蛮多的，这里就不赘述了。\n之前在开发中实现分布式锁都是自己基于 Redis 造轮子，虽然也不复杂并且自己实现一次能对分布式锁有更深的了解，但是终归有些麻烦。尤其是新项目需要的时候还得 CV 一次。\n在查询/学习过程中（毫不意外地）发现 Spring 有现成的组件实现，所以决定拿过来使用一次，顺便了解一下。\n使用 引入依赖 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-integration\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.integration\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-integration-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 创建相关的 Bean 1 2 3 4 5 6 7 8 @Configuration public class RedisLockConfig { @Bean public RedisLockRegistry redisLockRegistry(RedisConnectionFactory redisConnectionFactory) { return new RedisLockRegistry(redisConnectionFactory, \u0026#34;lock\u0026#34;); } } 相关代码示例 这里省略注入部分代码，仅展示使用部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 获取锁对象 Lock lock = redisLockRegistry.obtain(\u0026#34;lock\u0026#34;); // 尝试上/获取锁 boolean isLocked = false; try { // 1s 内持续尝试获取锁 isLocked = lock.tryLock(1, TimeUnit.SECONDS); } catch (InterruptedException e) { // 获取锁异常 log.error(\u0026#34;get lock fail\u0026#34;, e); // …… } if (isLocked) { // 获取锁成功 try { // 业务逻辑 log.info(\u0026#34;get lock success\u0026#34;); } catch (Exception e) { // 业务逻辑异常 log.error(\u0026#34;do sth fail\u0026#34;, e); } finally { // 确保解锁 lock.unlock(); } } else { // 获取锁失败 log.info(\u0026#34;get lock fail\u0026#34;); // …… } 踩坑 问题描述 为了尽可能简单测试加锁效果，我的做法是创建一个获取锁不释放的接口，然后重复调用。这样第一次获取锁成功后，后面的调用应该在过期时间内是无法获取的。\n上面都没什么问题，然后我尝试手动删掉 redis 里的锁记录之后发现还是锁着的。甚至超时时间过去之后依然是锁着的。\n排查 当然很容易想到除了 redis，应该还会有其他地方保存着锁信息，这个通过打断点很容易发现： 很明显，在下面获取 redis 锁之前先尝试获取了 localLock 的锁，虽然 redis 的锁已经没了，但 localLock 仍然还在，所以依然被锁。\n只有在 localLock 没被锁，能够获取锁的情况下才回去尝试获取 redis 的锁。然后如果获取 redis 锁失败（返回 false）的情况下又把 localLock 解锁。感觉这部分逻辑有点怪，不排除是个 BUG？之后再研究下吧。\n解决 解决起来也很方便，随便 Google 一下就能找到一篇文档： Distributed lock with Redis and Spring Boot\nIn some situations, you might need to acquire a lock but not release it. For example, you have a @Scheduled task that runs each 15 seconds on each instance and you don’t want it to be run more often than once per 15 seconds.\nTo do it you can get a lock and exit from a method without releasing. In such cases, I suggest calling lockRegistry.expireUnusedOlderThan(TTL) each time before obtaining a lock (actually it is better to call it for all cases). This method removes old not released locks from the map locks and prevents the situation when one instance has a map with old locks and all threads of this instance (except the one which acquired this lock) cannot acquire it.\n按以上的介绍，建议每次获取锁前都调用一次lockRegistry.expireUnusedOlderThan(TTL)来避免问题，按这种方法来进行操作确实解决了该问题。 （不得不吐槽一句，使用中文检索到的相关博文没有看到有提到这一点的……）\n","date":"2023-09-26T11:21:00Z","permalink":"https://cbconne.github.io/p/%E4%BD%BF%E7%94%A8-spring-integration-%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E-redis-%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BB%A5%E5%8F%8A%E8%B8%A9%E5%9D%91/","title":"使用 Spring Integration 实现基于 Redis 的分布式锁以及踩坑"}]